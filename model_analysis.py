#!/usr/bin/env python

import sys
from sklearn.mixture import GMM
import numpy
import scipy


if len(sys.argv) < 2:
	print "Usage: <concordance output> (as generated by the concordance script)"
	sys.exit(0)

f=open(sys.argv[1])
data=[]
values=[]
for l in f.readlines():
	x=float(l.split()[2])
	data.append([x])
	z=(l.split()[0], l.split()[1])
	values.append(z)
f.close()

gmix=GMM(n_components=2, covariance_type='full')
gmix.fit(data)


print gmix.means_
print gmix.weights_
print gmix.covars_

means = [gmix.means_[0][0], gmix.means_[1][0]]
sds = [numpy.sqrt(gmix.covars_[0][0][0]), numpy.sqrt(gmix.covars_[1][0][0])]

print means
print sds
lowerCutoffs = [means[0] - 2*sds[0], means[1]-2*sds[1]]
upperCutoffs = [means[0] + 2*sds[0], means[1]+2*sds[1]]

if upperCutoffs[0] >= lowerCutoffs[1]:
	print "no gap between distributions for alternative values"


sample = values[0][0]
relatives = []
for data, address in zip(data, values):
	if address[0] != sample:
		print "sample %s is related to: %s" %(sample, relatives)
		sample = address[0]
		relatives = []
	if data < lowerCutoffs[0]:
		print "reject concordance value as lower than anything in the data (%s, %s) with maximum density %1.4f" %(address[0], address[1], 0.3)
	elif data > upperCutoffs[0] and data < lowerCutoffs[1]:
		print "reject concordance value as in between related and unrelated samples (%s, %s) with maximum density %1.4f, %1.4f" %(address[0], address[1], scipy.stats.norm.cdf(data, means[0], sds[0]), scipy.stats.norm.cdf(data, means[1], sds[1]))
	elif data > upperCutoffs[1]:
		print "reject concordance value as higher than anything in the data (%s, %s)" %(address[0], address[1])
	elif data >= lowerCutoffs[1]:
		relatives.append(address[1])

print "sample %s is related to: %s" %(sample, relatives)



sys.exit(0)

n=10000
sample = gmix.sample(n)
#for x in gmix.score(sample):
#	print "%1.5f," %(x),
ss = sorted(gmix.score(sample))
print ss[:5]
rejects = []
dd = sorted( zip(gmix.score(data), values), key=lambda x: x[0])
data_size = len(data)
i=0
j=0
for x in dd:
	while x[0]>ss[j] and j < n:
		j+=1
	f = data_size*float(j)/n/2
	if f < 0.05:
		rejects.append(x[1])
		print x, float(j)/n
		i+=1
	else :
		break

current = values[0][0]
relations = []
for component, address in zip(gmix.predict(data),values):
	if address[0] != current:
		print current, relations
		current = address[0]
		relations = []
	if address in rejects:
		print "Concordance value has been rejected as neither related nor random for pair\n%s, %s\nInvestigate for possible contamination or other issues." %(address[0], address[1])
	elif component == 1:
		relations.append(address[1])
	else:
		pass

